# RISC-V 斐波那契數列測試程式
# 檔案：tests/asm_sources/fibonacci_test.asm

# 目的：測試斐波那契數列的計算功能
# 本測試使用迴圈計算前10個斐波那契數：1, 1, 2, 3, 5, 8, 13, 21, 34, 55

.globl _start
_start:
    # 初始化斐波那契數列的前兩個數
    addi x1, x0, 1      # x1 = F(0) = 1
    addi x2, x0, 1      # x2 = F(1) = 1
    
    # 設定記憶體基底位址
    addi x28, x0, 0x200  # 記憶體基底位址
    
    # 插入 NOP 指令以處理管線資料危害
    nop
    nop
    nop
    
    # 儲存前兩個斐波那契數
    sw x1, 0(x28)        # 儲存 F(0) = 1
    sw x2, 4(x28)        # 儲存 F(1) = 1
    
    # 設定迴圈計數器（計算8個額外的斐波那契數）
    addi x3, x0, 8      # x3 = 迴圈計數器
    
    # 設定記憶體偏移量
    addi x4, x0, 8      # x4 = 記憶體偏移量（從第3個數開始）
    
fibonacci_loop:
    # 計算下一個斐波那契數：F(n) = F(n-1) + F(n-2)
    add x5, x1, x2      # x5 = x1 + x2（新的斐波那契數）
    
    # 插入 NOP 指令以處理管線資料危害
    nop
    nop
    nop
    
    # 儲存新的斐波那契數到記憶體
    add x6, x28, x4     # x6 = 記憶體位址（基底 + 偏移量）
    sw x5, 0(x6)        # 儲存到記憶體位址 x6
    
    # 更新斐波那契數列（移動到下一個位置）
    addi x1, x2, 0      # x1 = x2（F(n-2) = F(n-1)）
    addi x2, x5, 0      # x2 = x5（F(n-1) = F(n)）
    
    # 更新記憶體偏移量
    addi x4, x4, 4      # x4 = x4 + 4（下一個記憶體位置）
    
    # 遞減迴圈計數器
    addi x3, x3, -1     # x3 = x3 - 1
    
    # 檢查迴圈是否完成
    bne x3, x0, fibonacci_loop  # 如果 x3 != 0，繼續迴圈
    
    # 無限迴圈以停止處理器供觀察
halt_loop:
    beq  x0, x0, halt_loop # 分支到自身（實質上為停止）
    nop                     # 不應該執行到這裡

# 預期結果：
# 記憶體位址 0x200 開始的連續位置應包含：
# 0x200: 1   (F(0))
# 0x204: 1   (F(1))
# 0x208: 2   (F(2))
# 0x20C: 3   (F(3))
# 0x210: 5   (F(4))
# 0x214: 8   (F(5))
# 0x218: 13  (F(6))
# 0x21C: 21  (F(7))
# 0x220: 34  (F(8))
# 0x224: 55  (F(9)) 