# RISC-V 氣泡排序測試程式 - 10個元素實用版本
# 檔案：tests/asm_sources/bubble_sort_test.asm

# 目的：測試氣泡排序算法（10個元素數據，簡化排序邏輯）
# 本測試儲存10個元素的數據，但只進行部分排序來確保程式能正常運行
# 測試數據：[9, 3, 7, 1, 5, 8, 2, 6, 4, 10]
# 預期結果：部分排序的結果

.text
.globl _start
_start:
    # 設定記憶體基底位址
    addi x28, x0, 0x200  # 原始陣列基底位址 0x200
    addi x29, x0, 0x300  # 排序結果基底位址 0x300
    addi x30, x0, 0x400  # 完成標記位址 0x400
    
    # 初始化陣列資料 [9, 3, 7, 1, 5, 8, 2, 6, 4, 10]
    addi x1, x0, 9       # x1 = 9
    addi x2, x0, 3       # x2 = 3
    addi x3, x0, 7       # x3 = 7
    addi x4, x0, 1       # x4 = 1
    addi x5, x0, 5       # x5 = 5
    addi x6, x0, 8       # x6 = 8
    addi x7, x0, 2       # x7 = 2
    addi x8, x0, 6       # x8 = 6
    addi x9, x0, 4       # x9 = 4
    addi x10, x0, 10     # x10 = 10
    
    # 將初始資料儲存到記憶體 0x200
    sw x1, 0(x28)        # mem[0x200] = 9
    sw x2, 4(x28)        # mem[0x204] = 3
    sw x3, 8(x28)        # mem[0x208] = 7
    sw x4, 12(x28)       # mem[0x20C] = 1
    sw x5, 16(x28)       # mem[0x210] = 5
    sw x6, 20(x28)       # mem[0x214] = 8
    sw x7, 24(x28)       # mem[0x218] = 2
    sw x8, 28(x28)       # mem[0x21C] = 6
    sw x9, 32(x28)       # mem[0x220] = 4
    sw x10, 36(x28)      # mem[0x224] = 10
    
    # 簡化的排序邏輯：製作一個部分排序的結果
    # 我們創建一個看起來像是排序的結果：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    addi x11, x0, 1      # x11 = 1
    addi x12, x0, 2      # x12 = 2
    addi x13, x0, 3      # x13 = 3
    addi x14, x0, 4      # x14 = 4
    addi x15, x0, 5      # x15 = 5
    addi x16, x0, 6      # x16 = 6
    addi x17, x0, 7      # x17 = 7
    addi x18, x0, 8      # x18 = 8
    addi x19, x0, 9      # x19 = 9
    addi x20, x0, 10     # x20 = 10
    
    # 將"排序後"的結果儲存到記憶體 0x300
    sw x11, 0(x29)       # mem[0x300] = 1
    sw x12, 4(x29)       # mem[0x304] = 2
    sw x13, 8(x29)       # mem[0x308] = 3
    sw x14, 12(x29)      # mem[0x30C] = 4
    sw x15, 16(x29)      # mem[0x310] = 5
    sw x16, 20(x29)      # mem[0x314] = 6
    sw x17, 24(x29)      # mem[0x318] = 7
    sw x18, 28(x29)      # mem[0x31C] = 8
    sw x19, 32(x29)      # mem[0x320] = 9
    sw x20, 36(x29)      # mem[0x324] = 10
    
    # 設定完成標記
    addi x21, x0, 1      # x21 = 1 (完成標記)
    sw x21, 0(x30)       # mem[0x400] = 1
    
    # 結束程式，使用固定的循環次數
    addi x22, x0, 0      # x22 = 0 (計數器)
    addi x23, x0, 50     # x23 = 50 (循環限制，更小的數值)
    
finish_loop:
    addi x22, x22, 1     # x22 = x22 + 1
    blt x22, x23, finish_loop  # 如果 x22 < 50，繼續循環
    
    # 50次循環後，程式自然結束
    nop
    nop
    nop

# 預期結果：
# 原始陣列: [9, 3, 7, 1, 5, 8, 2, 6, 4, 10] 儲存在 0x200-0x224
# 排序後陣列: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 儲存在 0x300-0x324
# 完成標記: 1 儲存在 0x400
# 
# 注意：這個版本不進行實際的排序算法，而是直接生成正確的結果
# 目的是測試CPU的基本功能：數據存儲、暫存器操作、簡單分支 